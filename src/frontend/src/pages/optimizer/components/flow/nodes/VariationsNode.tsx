import React, { useState, useEffect } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Loader2, Copy, Info, BadgePlus } from 'lucide-react';
import { useFlowStore } from '../../../../../stores/flowstoreNew';
import { VariationsNodeData } from '../../../../../types/flowTypes';
import { ModelSelector } from '../../model-selector';
import { generateTestCases } from '../../../../../lib/ai-providers';
import { useToast } from '../../../../../hooks/use-toast';
import { copyToClipboard } from '../../../../../lib/utils';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "../../../../../components/ui/tooltip";

// Variations Node component
const VariationsNode: React.FC<NodeProps<VariationsNodeData>> = ({ id, data }) => {
  const [modelConfig, setModelConfig] = useState(data.modelConfig);
  const [activeTab, setActiveTab] = useState('0');
  const [error, setError] = useState<string | null>(null);
  const [tokenCounts, setTokenCounts] = useState<Record<number, number>>({});
  const { updateNodeData } = useFlowStore();
  const { toast } = useToast();

  // Update token counts when variations change
  useEffect(() => {
    const newTokenCounts: Record<number, number> = {};
    data.variations.forEach((variation, index) => {
      // Rough estimate: 4 chars per token for English text
      newTokenCounts[index] = Math.ceil(variation.content.length / 4);
    });
    setTokenCounts(newTokenCounts);
  }, [data.variations]);

  // Update model config when data changes
  useEffect(() => {
    if (data.modelConfig !== modelConfig) {
      setModelConfig(data.modelConfig);
    }
  }, [data.modelConfig, modelConfig]);

  // Add a new empty variation
  const handleAddVariation = () => {
    const updatedVariations = [...data.variations];
    const newVariationId = updatedVariations.length;
    
    updatedVariations.push({
      id: newVariationId,
      metaPromptId: data.metaPrompt?.id || 0,
      content: "",
      modelConfig,
    });

    updateNodeData(id, { variations: updatedVariations });
    setActiveTab(String(newVariationId));
  };

  // Handle content update for a variation
  const handleVariationChange = (index: number, content: string) => {
    const updatedVariations = [...data.variations];
    if (updatedVariations[index]) {
      updatedVariations[index] = {
        ...updatedVariations[index],
        content
      };

      updateNodeData(id, { variations: updatedVariations });
      
      // Update token count
      setTokenCounts(prev => ({
        ...prev,
        [index]: Math.ceil(content.length / 4)
      }));
    }
    
    // Clear any error
    setError(null);
  };

  // Handle copy to clipboard
  const handleCopy = (content: string) => {
    copyToClipboard(content);
    toast({
      title: 'Copied',
      description: 'Variation copied to clipboard',
    });
  };

  // Handle generating test cases
  const handleGenerateTestCases = async () => {
    if (data.variations.length === 0) {
      setError("No variations to generate test cases from");
      toast({
        title: 'Error',
        description: 'No variations to generate test cases from',
        variant: 'destructive',
      });
      return;
    }

    // Check if the active variation has content
    const activeVariation = data.variations[parseInt(activeTab, 10)];
    if (!activeVariation || !activeVariation.content.trim()) {
      setError("The selected variation is empty");
      toast({
        title: 'Error',
        description: 'The selected variation is empty',
        variant: 'destructive',
      });
      return;
    }

    // Reset error state
    setError(null);

    // Use the meta prompt to generate test cases
    const metaPromptContent = data.metaPrompt?.generatedPrompt || activeVariation.content;
    
    // Update test cases node to indicate generation is in progress
    const testCasesNode = useFlowStore.getState().getNodeByType('testCasesNode');
    if (testCasesNode) {
      updateNodeData(testCasesNode.id, { 
        isGenerating: true, 
        modelConfig,
        metaPrompt: data.metaPrompt
      });
    }

    try {
      // Generate test cases
      const testCaseInputs = await generateTestCases(metaPromptContent, modelConfig);
      
      // Create test case objects
      const testCases = testCaseInputs.map((input, index) => ({
        id: index,
        metaPromptId: data.metaPrompt?.id || 0,
        input,
        isAutoGenerated: true,
      }));

      // Update test cases node with generated content
      if (testCasesNode) {
        updateNodeData(testCasesNode.id, {
          testCases,
          isGenerating: false,
        });
      }

      toast({
        title: 'Success',
        description: 'Test cases generated successfully',
      });
    } catch (error) {
      // Set error state
      const errorMessage = error instanceof Error ? error.message : 'An error occurred';
      setError(errorMessage);
      
      toast({
        title: 'Generation Failed',
        description: errorMessage,
        variant: 'destructive',
      });
      
      // Reset test cases node generation state
      if (testCasesNode) {
        updateNodeData(testCasesNode.id, { isGenerating: false });
      }
    }
  };

  return (
    <Card className="w-96 shadow-md">
      <CardHeader className="bg-primary/10 py-3 flex flex-row items-center justify-between">
        <CardTitle className="text-lg flex items-center">
          Prompt Variations
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Info className="h-4 w-4 ml-2 cursor-help text-muted-foreground" />
              </TooltipTrigger>
              <TooltipContent>
                <p className="max-w-xs">
                  Different variations of the system prompt that will be evaluated. You can edit these or add your own.
                </p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </CardTitle>
        {data.variations.length > 0 && (
          <Button 
            variant="ghost" 
            size="icon" 
            onClick={handleAddVariation}
            title="Add new variation"
          >
            <BadgePlus className="h-4 w-4" />
          </Button>
        )}
      </CardHeader>
      <CardContent className="pt-4 space-y-4">
        {data.isGenerating ? (
          <div className="flex flex-col justify-center items-center h-40 gap-2">
            <Loader2 className="h-8 w-8 animate-spin text-primary" />
            <span className="text-sm text-muted-foreground">Generating variations...</span>
          </div>
        ) : (
          <div className="space-y-4">
            {data.variations.length > 0 ? (
              <>
                <div className="space-y-2">
                  <Label>Model Configuration</Label>
                  <ModelSelector
                    value={modelConfig}
                    onChange={setModelConfig}
                  />
                </div>

                <Tabs value={activeTab} onValueChange={setActiveTab}>
                  <TabsList className="w-full grid" style={{ gridTemplateColumns: `repeat(${data.variations.length}, 1fr)` }}>
                    {data.variations.map((_, index) => (
                      <TabsTrigger key={index} value={index.toString()}>
                        V{index + 1}
                      </TabsTrigger>
                    ))}
                  </TabsList>

                  {data.variations.map((variation, index) => (
                    <TabsContent key={index} value={index.toString()} className="space-y-4">
                      <div className="flex justify-end">
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => handleCopy(variation.content)}
                        >
                          <Copy className="h-4 w-4 mr-2" />
                          Copy
                        </Button>
                      </div>

                      <Textarea
                        value={variation.content}
                        onChange={(e) => handleVariationChange(index, e.target.value)}
                        className={`min-h-40 font-mono text-sm ${error ? 'border-red-500 focus-visible:ring-red-500' : ''}`}
                      />
                      
                      <div className="text-xs text-muted-foreground text-right">
                        ~{tokenCounts[index] || 0} tokens
                      </div>
                    </TabsContent>
                  ))}
                </Tabs>

                {error && <p className="text-sm text-red-500">{error}</p>}

                <Button
                  onClick={handleGenerateTestCases}
                  className="w-full"
                  disabled={data.variations.length === 0}
                >
                  Generate Test Cases
                </Button>
              </>
            ) : (
              <div className="text-center py-10 text-muted-foreground flex flex-col gap-4">
                <p>Generate meta prompt variations to continue.</p>
                <Button onClick={handleAddVariation} variant="outline">
                  <BadgePlus className="h-4 w-4 mr-2" />
                  Add Empty Variation
                </Button>
              </div>
            )}
          </div>
        )}
      </CardContent>

      {/* Input handle */}
      <Handle
        type="target"
        position={Position.Top}
        id="input"
        className="w-3 h-3 bg-primary"
      />

      {/* Output handle */}
      <Handle
        type="source"
        position={Position.Bottom}
        id="output"
        className="w-3 h-3 bg-primary"
      />
    </Card>
  );
};

export default VariationsNode;